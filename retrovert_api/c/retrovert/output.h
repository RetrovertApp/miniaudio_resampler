///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This file is auto-generated by api_generator. DO NOT EDIT!
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "rv_types.h"

#ifdef _cplusplus
extern "C" {
#endif

#include "audio_format.h"
#include "service.h"
#include "settings.h"
#define RV_OUTPUT_PLUGIN_API_VERSION 1

typedef struct RVWriteInfo {
    uint32_t sample_rate;
    uint16_t sample_count;
    uint8_t channel_count;
    uint8_t output_format;
} RVWriteInfo;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

typedef struct RVPlaybackCallback {
    void* user_data;
    // Starts playback of the data.
    // `format` describes the out that the callback is supposed to generate
    // `frames` parameter tells you how many frames can be written to the output buffer and read from the input buffer.
    //  A "frame" is one sample for each channel. For example, in a stereo stream (2 channels), one frame is 2
    //  samples: one for the left, one for the right.
    uint32_t (*callback)(void* user_data, void* data, RVAudioFormat format, uint32_t frames);
} RVPlaybackCallback;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

typedef struct RVOutputTargets {
    const char** names;
    uint64_t names_size;
} RVOutputTargets;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This is for implementing a plugin where audio is decoded to at the end of a whole chain. This is tyically used for
// audio devices or writing the output to a file (such as a WAV writer)
typedef struct RVOutputPlugin {
    // Version of the API. This has to be set to RV_PLAYBACK_PLUGIN_API_VERSION
    uint64_t api_version;
    // Name of the plugin. This name should be unique or it may fail to load if there is a collision.
    const char* name;
    // Scematic version of the plugin. If the version doesn't follow the rules of SemVersion it may fail to load.
    const char* version;
    // Scematic version of library being used. Useful if you only update lib x from 0.1 to 0.2 but no other changes to
    // plugin In case the plugin doesn't use any external library this can be set to "" or NULL
    const char* library_version;
    // Creates an instance of the plugin
    void* (*create)(const RVService* services);
    // Destroy the instance of the plugin. It's expected that the user will free the user_data pointer at
    // this point as it won't be used anymore.
    int (*destroy)(void* user_data);
    // List of output targets this plugin supports. For example this can be a list of all sound devcies in a system, or
    // encoding formats that is supported. It's expected that the plugin returns at least one valid output, otherwise
    // the host will consider it that the plugin can't be used to produce any meaningful data.
    RVOutputTargets (*output_targets_info)(void* user_data);
    // Starts playback of the data.
    void (*start)(void* user_data, RVPlaybackCallback* callback);
    // Stops playback of the data
    void (*stop)(void* user_data);
    // Called once for each plugin. This allows the plugin to setup an instance of the logging api
    void (*static_init)(const RVService* services);
} RVOutputPlugin;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef _cplusplus
}
#endif