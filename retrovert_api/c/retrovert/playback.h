///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This file is auto-generated by api_generator. DO NOT EDIT!
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "rv_types.h"

#ifdef _cplusplus
extern "C" {
#endif

#include "audio_format.h"
#include "log.h"
#include "service.h"
#include "settings.h"
#define RV_PLAYBACK_PLUGIN_API_VERSION 1

typedef enum RVProbeResult {
    RVProbeResult_Supported = 0,
    RVProbeResult_Unsupported = 1,
    RVProbeResult_Unsure = 2,
} RVProbeResult;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Sets status of the data returned in the ReadInfo
typedef enum RVReadStatus {
    // This is set by default when the host requests data. Decoders are expected to set any of the below statuses
    RVReadStatus_DecodingRequest = 0,
    // Decoding of frames where ok
    RVReadStatus_Ok = 1,
    // Frames where decoded and that there are no more data left (such at the end of a song)
    RVReadStatus_Finished = 2,
    // Something went wrong when decoding the frames. The playback/decoder should use the logging system to
    // report more details on the actual error
    RVReadStatus_Error = 3,
} RVReadStatus;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

typedef enum RVPlaybackType {
    // Tracker-based playback type (i.e music based on pre-defined patterns)
    RVPlaybackType_Tracker = 0,
    // Hardware emulated means that a soundchip is being emulated and that frequencies, volumes, etc is being set.
    RVPlaybackType_HardwareEmulated = 1,
    // Streamed is usual for MP3/FLAC/etc formats
    RVPlaybackType_Streamed = 2,
} RVPlaybackType;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This struct contains info on what format the host expects as output.
// If the decoder can match the output the host has to do less converting, but isn't required.
// The `frame_count` parameter tells you how many frames can be written to the output buffer and read from the input
// buffer. A "frame" is one sample for each channel. For example, in a stereo stream (2 channels), one frame is 2
// samples: one for the left, one for the right. The channel count is defined by the device config. The size in bytes of
// an individual sample is defined by the sample format which is also specified in the device config. Multi-channel
// audio data is always interleaved, which means the samples for each frame are stored next to each other in memory. For
// example, in a stereo stream the first pair of samples will be the left and right samples for the first frame, the
// second pair of samples will be the left and right samples for the second frame, etc.
typedef struct RVReadInfo {
    RVAudioFormat format;
    uint32_t frame_count;
    RVReadStatus status;
    uint16_t virtual_channel_count;
} RVReadInfo;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

typedef struct RVReadData {
    // Output for channel data. If there is more than one channel it's expected the data to be interleaved.
    void* channels_output;
    // Output for virtual channels. This is mainly for data visualzation, but can also be used if the user
    // wants to render out a song with all channels separated. This value is null and info.virtual_channel_count
    // is zero when this data shouldn't be filled in. If the decoder doesn't support this virtual_chann_count should
    // be set to zero when returing the read_info from [PlaybackPlugin::read_data]
    void* virtual_channel_output;
    // Max number of bytes to write to the channels_output. Notice it's fine to write less as long as the correct amount
    uint32_t channels_output_max_bytes_size;
    // Max number of bytes to write to the channels_output. Notice it's fine to write less as long as the correct amount
    uint32_t virtual_channels_output_max_bytes_size;
    RVReadInfo info;
} RVReadData;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

typedef struct RVPlaybackInfo {
    // These are the number of "virtual" channels used by the song. In tracker music these would be
    // the total number of channels. If the format/plugin doesn't support retriving individual channels
    // then this number should be set to zero
    uint32_t virtual_channel_count;
    // Playback type
    RVPlaybackType playback_type;
} RVPlaybackInfo;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

typedef struct RVPlaybackPlugin {
    // Version of the API. This has to be set to RV_PLAYBACK_PLUGIN_API_VERSION
    uint64_t api_version;
    // Name of the plugin. This name should be unique or it may fail to load if there is a collision.
    const char* name;
    // Scematic version of the plugin. If the version doesn't follow the rules of SemVersion it may fail to load.
    const char* version;
    // Scematic version of library being used. Useful if you only update lib x from 0.1 to 0.2 but no other changes to
    // plugin In case the plugin doesn't use any external library this can be set to "" or NULL
    const char* library_version;
    // Ask the plugin if it can play some data. The plugin has to determine from the header if it supports the
    // file or not. The input data is at least 2048 bytes but can be less if the the total file is smaller.
    // Notice that no user data is provided with this as the plugin instance hasn't actually been created
    // The plugin must support to parse this data without custom data being setup.
    // It's encouraged that plugins detect the song-type based on metadata, but the filename is included
    // in case that is the only option to detect support for the file type
    RVProbeResult (*probe_can_play)(uint8_t* data, uint64_t data_size, const char* filename, uint64_t total_size);
    // Returns a comma separated list of supported extensions
    const char* (*supported_extensions)();
    void* (*create)(const RVService* services);
    // Destroy the instance of the plugin. It's expected that the user will free the user_data pointer at
    // this point as it won't be used anymore.
    int (*destroy)(void* user_data);
    // TODO
    void (*event)(void* user_data, uint8_t* data, uint64_t data_size);
    // Opens a buffer to be ready for playback. Buffer may be a file/archived/file or a file or a network resource.
    // Use the RVFileAPI that can be optained from services to load the data
    int (*open)(void* user_data, const char* url, uint32_t subsong, const RVService* services);
    // Closes the file buffer that was opened in open. Notice that the plugin isn't detroyed at this but but is
    // here for closing an open file/stream/etc
    void (*close)(void* user_data);
    // Called when sample data is requested from the host
    // The plugin is allowed to return as many samples as it want's as long as it doesn't go above max sample count
    RVReadInfo (*read_data)(void* user_data, RVReadData dest);
    // Called requesting a new location in the data
    int64_t (*seek)(void* user_data, int64_t ms);
    // Called to see if the plugin can provide some metadata given an url
    int (*metadata)(const char* url, const RVService* services);
    // Called once for each plugin. This allows the plugin to setup an instance of the logging api
    void (*static_init)(const RVService* services);
    // Called when the user has changed some settings
    RVSettingsUpdate (*settings_updated)(void* user_data, const RVService* services);
} RVPlaybackPlugin;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef _cplusplus
}
#endif